/**
 * Port Scanner - KYOKO MD Pentest Feature
 * Scan open ports on a target host (lightweight, CPU-friendly)
 * Developer: ZetaGo-Aurum
 * 
 * Note: Uses Node.js native net module for stability
 */

const net = require('net');

const pluginConfig = {
    name: 'portscan',
    alias: ['scanport', 'port', 'ps'],
    category: 'pentest',
    description: 'Scan port terbuka pada target host',
    usage: '.portscan <host> [port-range]',
    example: '.portscan example.com 1-1000',
    isOwner: false,
    isPremium: true,
    isGroup: false,
    isPrivate: false,
    cooldown: 30,
    limit: 1,
    isEnabled: true
};

// Common ports to scan
const COMMON_PORTS = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080, 8443];

/**
 * Scan single port
 */
function scanPort(host, port, timeout = 2000) {
    return new Promise((resolve) => {
        const socket = new net.Socket();
        let status = 'closed';
        
        socket.setTimeout(timeout);
        
        socket.on('connect', () => {
            status = 'open';
            socket.destroy();
        });
        
        socket.on('timeout', () => {
            socket.destroy();
        });
        
        socket.on('error', () => {
            socket.destroy();
        });
        
        socket.on('close', () => {
            resolve({ port, status });
        });
        
        socket.connect(port, host);
    });
}

async function handler(m, { sock }) {
    const args = m.text?.trim()?.split(' ') || [];
    const host = args[0];
    
    if (!host) {
        return m.reply(`‚ùå Format: .portscan <host> [port-range]\n\nContoh:\n‚Ä¢ .portscan example.com\n‚Ä¢ .portscan 192.168.1.1 1-100\n‚Ä¢ .portscan example.com 80,443,8080`);
    }
    
    // Validate host (basic)
    if (!/^[a-zA-Z0-9.-]+$/.test(host)) {
        return m.reply(`‚ùå Invalid host format!`);
    }
    
    await m.reply(`üîç *·¥ò·¥è Ä·¥õ Íú±·¥Ñ·¥Ä…¥…¥·¥á Ä*\n\n‚è≥ Scanning ${host}...\n> Mohon tunggu...`);
    
    let portsToScan = COMMON_PORTS;
    
    // Parse port range if provided
    if (args[1]) {
        const portArg = args[1];
        if (portArg.includes('-')) {
            const [start, end] = portArg.split('-').map(Number);
            if (start > 0 && end <= 65535 && start <= end && (end - start) <= 500) {
                portsToScan = [];
                for (let i = start; i <= end; i++) {
                    portsToScan.push(i);
                }
            }
        } else if (portArg.includes(',')) {
            portsToScan = portArg.split(',').map(Number).filter(p => p > 0 && p <= 65535);
        }
    }
    
    // Limit ports to scan (CPU friendly)
    portsToScan = portsToScan.slice(0, 100);
    
    try {
        const startTime = Date.now();
        const results = [];
        
        // Scan in batches of 10 for CPU efficiency
        for (let i = 0; i < portsToScan.length; i += 10) {
            const batch = portsToScan.slice(i, i + 10);
            const batchResults = await Promise.all(
                batch.map(port => scanPort(host, port, 1500))
            );
            results.push(...batchResults);
        }
        
        const openPorts = results.filter(r => r.status === 'open');
        const scanTime = ((Date.now() - startTime) / 1000).toFixed(2);
        
        let txt = `üîç *·¥ò·¥è Ä·¥õ Íú±·¥Ñ·¥Ä…¥  Ä·¥áÍú±·¥ú ü·¥õ*\n\n`;
        txt += `üéØ Target: \`${host}\`\n`;
        txt += `üìä Scanned: ${portsToScan.length} ports\n`;
        txt += `‚è±Ô∏è Time: ${scanTime}s\n\n`;
        
        if (openPorts.length > 0) {
            txt += `‚úÖ *·¥è·¥ò·¥á…¥ ·¥ò·¥è Ä·¥õÍú±* (${openPorts.length})\n`;
            openPorts.forEach(p => {
                const service = getServiceName(p.port);
                txt += `  ‚ó¶ Port ${p.port} ${service ? `(${service})` : ''}\n`;
            });
        } else {
            txt += `> Tidak ada port terbuka yang ditemukan.`;
        }
        
        await m.reply(txt);
        
    } catch (error) {
        await m.reply(`‚ùå Scan gagal: ${error.message}`);
    }
}

function getServiceName(port) {
    const services = {
        21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
        53: 'DNS', 80: 'HTTP', 110: 'POP3', 143: 'IMAP',
        443: 'HTTPS', 445: 'SMB', 3306: 'MySQL', 3389: 'RDP',
        5432: 'PostgreSQL', 5900: 'VNC', 6379: 'Redis',
        8080: 'HTTP-Alt', 8443: 'HTTPS-Alt', 27017: 'MongoDB'
    };
    return services[port] || '';
}

module.exports = { config: pluginConfig, handler };
