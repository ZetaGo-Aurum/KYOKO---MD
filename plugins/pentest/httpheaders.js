/**
 * HTTP Security Headers Analyzer - KYOKO MD Pentest Feature
 * Analyze security headers of a website
 * Developer: ZetaGo-Aurum
 */

const https = require('https');
const http = require('http');
const { URL } = require('url');

const pluginConfig = {
    name: 'httpheaders',
    alias: ['securityheaders', 'headers', 'headercheck'],
    category: 'pentest',
    description: 'Analisis security headers website',
    usage: '.httpheaders <url>',
    example: '.httpheaders https://example.com',
    isOwner: false,
    isPremium: false,
    isGroup: false,
    isPrivate: false,
    cooldown: 10,
    limit: 0,
    isEnabled: true
};

// Security headers to check with descriptions
const SECURITY_HEADERS = {
    'strict-transport-security': {
        name: 'HSTS',
        description: 'Memaksa koneksi HTTPS',
        severity: 'high',
        recommendation: 'Tambahkan: Strict-Transport-Security: max-age=31536000; includeSubDomains'
    },
    'content-security-policy': {
        name: 'CSP',
        description: 'Mencegah XSS dan injection',
        severity: 'high',
        recommendation: 'Tambahkan CSP yang sesuai dengan kebutuhan aplikasi'
    },
    'x-frame-options': {
        name: 'X-Frame-Options',
        description: 'Mencegah clickjacking',
        severity: 'medium',
        recommendation: 'Tambahkan: X-Frame-Options: DENY atau SAMEORIGIN'
    },
    'x-content-type-options': {
        name: 'X-Content-Type-Options',
        description: 'Mencegah MIME sniffing',
        severity: 'medium',
        recommendation: 'Tambahkan: X-Content-Type-Options: nosniff'
    },
    'x-xss-protection': {
        name: 'X-XSS-Protection',
        description: 'Filter XSS browser',
        severity: 'low',
        recommendation: 'Tambahkan: X-XSS-Protection: 1; mode=block'
    },
    'referrer-policy': {
        name: 'Referrer-Policy',
        description: 'Kontrol informasi referrer',
        severity: 'low',
        recommendation: 'Tambahkan: Referrer-Policy: strict-origin-when-cross-origin'
    },
    'permissions-policy': {
        name: 'Permissions-Policy',
        description: 'Kontrol fitur browser',
        severity: 'low',
        recommendation: 'Batasi akses ke fitur seperti camera, microphone, geolocation'
    },
    'x-permitted-cross-domain-policies': {
        name: 'X-Permitted-Cross-Domain-Policies',
        description: 'Kontrol kebijakan lintas domain',
        severity: 'low',
        recommendation: 'Tambahkan: X-Permitted-Cross-Domain-Policies: none'
    },
    'expect-ct': {
        name: 'Expect-CT',
        description: 'Certificate Transparency',
        severity: 'low',
        recommendation: 'Tambahkan: Expect-CT: enforce, max-age=86400'
    }
};

// Headers that should NOT be present (information leakage)
const SENSITIVE_HEADERS = [
    'server',
    'x-powered-by',
    'x-aspnet-version',
    'x-aspnetmvc-version'
];

function makeRequest(url, timeout = 10000) {
    return new Promise((resolve) => {
        try {
            const parsedUrl = new URL(url);
            const protocol = parsedUrl.protocol === 'https:' ? https : http;
            
            const req = protocol.get(url, {
                timeout,
                rejectUnauthorized: false,
                headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0' }
            }, (res) => {
                resolve({ status: res.statusCode, headers: res.headers });
            });
            
            req.on('error', () => resolve({ status: 0, error: true }));
            req.on('timeout', () => {
                req.destroy();
                resolve({ status: 0, timeout: true });
            });
        } catch (e) {
            resolve({ status: 0, error: true });
        }
    });
}

async function handler(m, { sock }) {
    let target = m.text?.trim();
    
    if (!target) {
        return m.reply(
            `üõ°Ô∏è *s·¥á·¥Ñ·¥ú Ä…™·¥õ è  ú·¥á·¥Ä·¥Ö·¥á Äs ·¥Ä…¥·¥Ä ü è·¥¢·¥á Ä*\n\n` +
            `> Analisis security headers website\n\n` +
            `*Penggunaan:*\n` +
            `> ${m.prefix}httpheaders <url>\n\n` +
            `*Contoh:*\n` +
            `> ${m.prefix}httpheaders https://example.com`
        );
    }
    
    if (!target.startsWith('http://') && !target.startsWith('https://')) {
        target = 'https://' + target;
    }
    
    try {
        new URL(target);
    } catch {
        return m.reply(`‚ùå URL tidak valid!`);
    }
    
    await m.reply(`üõ°Ô∏è * ú·¥á·¥Ä·¥Ö·¥á Ä ·¥Ä…¥·¥Ä ü è·¥¢·¥á Ä*\n\n‚è≥ Checking ${target}...\n> Mohon tunggu...`);
    
    try {
        const result = await makeRequest(target);
        
        if (result.error || result.timeout) {
            return m.reply(`‚ùå Tidak dapat mengakses website!`);
        }
        
        const present = [];
        const missing = [];
        const infoLeak = [];
        
        // Check security headers
        for (const [header, info] of Object.entries(SECURITY_HEADERS)) {
            if (result.headers[header]) {
                present.push({
                    name: info.name,
                    value: result.headers[header].substring(0, 60),
                    severity: info.severity
                });
            } else {
                missing.push({
                    name: info.name,
                    severity: info.severity,
                    recommendation: info.recommendation
                });
            }
        }
        
        // Check info leakage headers
        for (const header of SENSITIVE_HEADERS) {
            if (result.headers[header]) {
                infoLeak.push({
                    name: header,
                    value: result.headers[header]
                });
            }
        }
        
        // Calculate score
        const totalHeaders = Object.keys(SECURITY_HEADERS).length;
        const score = Math.round((present.length / totalHeaders) * 100);
        const grade = score >= 80 ? 'A' : score >= 60 ? 'B' : score >= 40 ? 'C' : score >= 20 ? 'D' : 'F';
        const gradeEmoji = score >= 80 ? 'üü¢' : score >= 60 ? 'üü°' : score >= 40 ? 'üü†' : 'üî¥';
        
        let txt = `üõ°Ô∏è *s·¥á·¥Ñ·¥ú Ä…™·¥õ è  ú·¥á·¥Ä·¥Ö·¥á Äs ·¥Ä…¥·¥Ä ü ès…™s*\n\n`;
        txt += `üéØ Target: \`${target}\`\n`;
        txt += `üìä Score: ${gradeEmoji} *${score}%* (Grade ${grade})\n\n`;
        
        // Present headers
        if (present.length > 0) {
            txt += `‚úÖ *·¥ò Ä·¥ás·¥á…¥·¥õ* (${present.length})\n`;
            txt += `‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ\n`;
            for (const h of present) {
                txt += `  ‚ó¶ ${h.name}\n`;
            }
            txt += `\n`;
        }
        
        // Missing headers
        if (missing.length > 0) {
            const highMissing = missing.filter(h => h.severity === 'high');
            const mediumMissing = missing.filter(h => h.severity === 'medium');
            const lowMissing = missing.filter(h => h.severity === 'low');
            
            txt += `‚ùå *·¥ç…™ss…™…¥…¢* (${missing.length})\n`;
            txt += `‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ\n`;
            
            if (highMissing.length > 0) {
                txt += `  üî¥ *High Priority:*\n`;
                highMissing.forEach(h => txt += `     ‚ó¶ ${h.name}\n`);
            }
            if (mediumMissing.length > 0) {
                txt += `  üü† *Medium Priority:*\n`;
                mediumMissing.forEach(h => txt += `     ‚ó¶ ${h.name}\n`);
            }
            if (lowMissing.length > 0) {
                txt += `  üü° *Low Priority:*\n`;
                lowMissing.forEach(h => txt += `     ‚ó¶ ${h.name}\n`);
            }
            txt += `\n`;
        }
        
        // Information leakage
        if (infoLeak.length > 0) {
            txt += `‚ö†Ô∏è *…™…¥Íú∞·¥è  ü·¥á·¥Ä·¥ã·¥Ä…¢·¥á*\n`;
            txt += `‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ\n`;
            for (const h of infoLeak) {
                txt += `  ‚ó¶ ${h.name}: ${h.value}\n`;
            }
            txt += `> _Headers ini mengekspos info server!_\n`;
        }
        
        await m.reply(txt);
        
    } catch (error) {
        await m.reply(`‚ùå Error: ${error.message}`);
    }
}

module.exports = { config: pluginConfig, handler };
