/**
 * Header Analyzer - KYOKO MD Pentest Feature
 * Analyze HTTP headers of a website
 * Developer: ZetaGo-Aurum
 */

const https = require('https');
const http = require('http');

const pluginConfig = {
    name: 'headers',
    alias: ['httpheader', 'headerscan', 'headerinfo'],
    category: 'pentest',
    description: 'Analisis HTTP headers website',
    usage: '.headers <url>',
    example: '.headers https://example.com',
    isOwner: false,
    isPremium: false,
    isGroup: false,
    isPrivate: false,
    cooldown: 10,
    limit: 0,
    isEnabled: true
};

function fetchHeaders(url) {
    return new Promise((resolve, reject) => {
        const protocol = url.startsWith('https') ? https : http;
        const options = {
            method: 'HEAD',
            headers: { 'User-Agent': 'KYOKO-MD Security Scanner/1.0' },
            timeout: 10000
        };
        
        const req = protocol.request(url, options, (res) => {
            resolve({
                statusCode: res.statusCode,
                headers: res.headers
            });
        });
        
        req.on('error', reject);
        req.on('timeout', () => {
            req.destroy();
            reject(new Error('Timeout'));
        });
        req.end();
    });
}

async function handler(m, { sock }) {
    let url = m.text?.trim();
    
    if (!url) {
        return m.reply(`âŒ Format: .headers <url>\n\nContoh: .headers https://example.com`);
    }
    
    // Add protocol if missing
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
        url = 'https://' + url;
    }
    
    await m.reply(`ğŸ” *Êœá´‡á´€á´…á´‡Ê€ á´€É´á´€ÊŸÊá´¢á´‡Ê€*\n\nâ³ Fetching headers from ${url}...`);
    
    try {
        const { statusCode, headers } = await fetchHeaders(url);
        
        // Security header analysis
        const securityHeaders = {
            'strict-transport-security': { name: 'HSTS', secure: true },
            'x-frame-options': { name: 'X-Frame-Options', secure: true },
            'x-content-type-options': { name: 'X-Content-Type-Options', secure: true },
            'x-xss-protection': { name: 'X-XSS-Protection', secure: true },
            'content-security-policy': { name: 'CSP', secure: true },
            'x-powered-by': { name: 'X-Powered-By', secure: false, warning: 'Info disclosure' }
        };
        
        let txt = `ğŸ” *Êœá´‡á´€á´…á´‡Ê€ á´€É´á´€ÊŸÊêœ±Éªêœ±*\n\n`;
        txt += `ğŸŒ URL: ${url}\n`;
        txt += `ğŸ“Š Status: ${statusCode}\n\n`;
        
        // Important headers
        txt += `ğŸ“‹ *Êœá´‡á´€á´…á´‡Ê€êœ±*\n`;
        const importantHeaders = ['server', 'content-type', 'x-powered-by', 'set-cookie'];
        importantHeaders.forEach(h => {
            if (headers[h]) {
                txt += `â—¦ ${h}: ${String(headers[h]).substring(0, 50)}\n`;
            }
        });
        
        txt += `\nğŸ”’ *êœ±á´‡á´„á´œÊ€Éªá´›Ê á´„Êœá´‡á´„á´‹*\n`;
        
        let score = 0;
        Object.entries(securityHeaders).forEach(([header, info]) => {
            const present = headers[header] !== undefined;
            if (info.secure) {
                txt += `${present ? 'âœ…' : 'âŒ'} ${info.name}\n`;
                if (present) score++;
            } else if (present && info.warning) {
                txt += `âš ï¸ ${info.name}: ${info.warning}\n`;
            }
        });
        
        txt += `\nğŸ“Š Security Score: ${score}/5`;
        
        await m.reply(txt);
        
    } catch (error) {
        await m.reply(`âŒ Fetch gagal: ${error.message}`);
    }
}

module.exports = { config: pluginConfig, handler };
