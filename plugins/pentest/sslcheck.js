/**
 * SSL/TLS Certificate Checker - KYOKO MD Pentest Feature
 * Check SSL certificate details and security
 * Developer: ZetaGo-Aurum
 */

const https = require('https');
const tls = require('tls');
const { URL } = require('url');

const pluginConfig = {
    name: 'sslcheck',
    alias: ['ssl', 'certificate', 'cert', 'tlscheck'],
    category: 'pentest',
    description: 'Cek sertifikat SSL/TLS website',
    usage: '.sslcheck <domain>',
    example: '.sslcheck example.com',
    isOwner: false,
    isPremium: false,
    isGroup: false,
    isPrivate: false,
    cooldown: 10,
    limit: 0,
    isEnabled: true
};

function getCertificate(hostname, port = 443, timeout = 10000) {
    return new Promise((resolve) => {
        try {
            const socket = tls.connect({
                host: hostname,
                port: port,
                servername: hostname,
                rejectUnauthorized: false,
                timeout: timeout
            }, () => {
                const cert = socket.getPeerCertificate(true);
                const protocol = socket.getProtocol();
                const cipher = socket.getCipher();
                socket.destroy();
                resolve({ success: true, cert, protocol, cipher });
            });
            
            socket.on('error', (err) => {
                resolve({ success: false, error: err.message });
            });
            
            socket.on('timeout', () => {
                socket.destroy();
                resolve({ success: false, error: 'Connection timeout' });
            });
        } catch (e) {
            resolve({ success: false, error: e.message });
        }
    });
}

function formatDate(date) {
    if (!date) return 'Unknown';
    const d = new Date(date);
    return d.toLocaleDateString('id-ID', { year: 'numeric', month: 'short', day: 'numeric' });
}

function getDaysUntilExpiry(validTo) {
    if (!validTo) return null;
    const expiry = new Date(validTo);
    const now = new Date();
    const diff = expiry - now;
    return Math.floor(diff / (1000 * 60 * 60 * 24));
}

function getGrade(cert, protocol, cipher) {
    let score = 100;
    
    // Check protocol
    if (protocol === 'TLSv1' || protocol === 'SSLv3') score -= 30;
    else if (protocol === 'TLSv1.1') score -= 20;
    else if (protocol === 'TLSv1.2') score -= 5;
    // TLSv1.3 is best, no deduction
    
    // Check cipher strength
    if (cipher && cipher.name) {
        if (cipher.name.includes('RC4') || cipher.name.includes('DES') || cipher.name.includes('MD5')) {
            score -= 30;
        } else if (cipher.name.includes('SHA1') && !cipher.name.includes('SHA256')) {
            score -= 10;
        }
    }
    
    // Check expiry
    const daysUntilExpiry = getDaysUntilExpiry(cert.valid_to);
    if (daysUntilExpiry !== null) {
        if (daysUntilExpiry < 0) score -= 50;
        else if (daysUntilExpiry < 7) score -= 30;
        else if (daysUntilExpiry < 30) score -= 15;
    }
    
    // Check key size
    if (cert.bits) {
        if (cert.bits < 2048) score -= 20;
    }
    
    if (score >= 90) return { grade: 'A+', emoji: 'ğŸŸ¢', color: 'Excellent' };
    if (score >= 80) return { grade: 'A', emoji: 'ğŸŸ¢', color: 'Good' };
    if (score >= 70) return { grade: 'B', emoji: 'ğŸŸ¡', color: 'Fair' };
    if (score >= 60) return { grade: 'C', emoji: 'ğŸŸ ', color: 'Weak' };
    if (score >= 50) return { grade: 'D', emoji: 'ğŸŸ ', color: 'Poor' };
    return { grade: 'F', emoji: 'ğŸ”´', color: 'Critical' };
}

async function handler(m, { sock }) {
    let target = m.text?.trim();
    
    if (!target) {
        return m.reply(
            `ğŸ” *ssÊŸ/á´›ÊŸs á´„á´‡Ê€á´›Éªêœ°Éªá´„á´€á´›á´‡ á´„Êœá´‡á´„á´‹á´‡Ê€*\n\n` +
            `> Cek sertifikat SSL/TLS website\n\n` +
            `*Penggunaan:*\n` +
            `> ${m.prefix}sslcheck <domain>\n\n` +
            `*Contoh:*\n` +
            `> ${m.prefix}sslcheck example.com\n` +
            `> ${m.prefix}sslcheck https://example.com`
        );
    }
    
    // Extract hostname from URL
    let hostname;
    try {
        if (target.startsWith('http://') || target.startsWith('https://')) {
            hostname = new URL(target).hostname;
        } else {
            hostname = target.split('/')[0].split(':')[0];
        }
    } catch {
        return m.reply(`âŒ Domain tidak valid!`);
    }
    
    await m.reply(`ğŸ” *ssÊŸ á´„Êœá´‡á´„á´‹*\n\nâ³ Checking ${hostname}...\n> Mohon tunggu...`);
    
    try {
        const result = await getCertificate(hostname);
        
        if (!result.success) {
            return m.reply(`âŒ Gagal mengecek SSL: ${result.error}`);
        }
        
        const { cert, protocol, cipher } = result;
        const grade = getGrade(cert, protocol, cipher);
        const daysUntilExpiry = getDaysUntilExpiry(cert.valid_to);
        
        let txt = `ğŸ” *ssÊŸ/á´›ÊŸs á´„á´‡Ê€á´›Éªêœ°Éªá´„á´€á´›á´‡ ÉªÉ´êœ°á´*\n\n`;
        txt += `ğŸ¯ Domain: \`${hostname}\`\n`;
        txt += `ğŸ“Š Grade: ${grade.emoji} *${grade.grade}* (${grade.color})\n\n`;
        
        // Certificate Info
        txt += `ğŸ“œ *á´„á´‡Ê€á´›Éªêœ°Éªá´„á´€á´›á´‡*\n`;
        txt += `â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„\n`;
        txt += `  â—¦ Subject: ${cert.subject?.CN || 'N/A'}\n`;
        txt += `  â—¦ Issuer: ${cert.issuer?.O || cert.issuer?.CN || 'N/A'}\n`;
        txt += `  â—¦ Valid From: ${formatDate(cert.valid_from)}\n`;
        txt += `  â—¦ Valid To: ${formatDate(cert.valid_to)}\n`;
        
        if (daysUntilExpiry !== null) {
            let expiryStatus;
            if (daysUntilExpiry < 0) {
                expiryStatus = `ğŸ”´ EXPIRED ${Math.abs(daysUntilExpiry)} days ago`;
            } else if (daysUntilExpiry < 7) {
                expiryStatus = `ğŸ”´ Expires in ${daysUntilExpiry} days!`;
            } else if (daysUntilExpiry < 30) {
                expiryStatus = `ğŸŸ¡ Expires in ${daysUntilExpiry} days`;
            } else {
                expiryStatus = `ğŸŸ¢ ${daysUntilExpiry} days remaining`;
            }
            txt += `  â—¦ Expiry: ${expiryStatus}\n`;
        }
        txt += `\n`;
        
        // Connection Security
        txt += `ğŸ”’ *á´„á´É´É´á´‡á´„á´›Éªá´É´*\n`;
        txt += `â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„\n`;
        txt += `  â—¦ Protocol: ${protocol || 'Unknown'}\n`;
        if (cipher) {
            txt += `  â—¦ Cipher: ${cipher.name || 'Unknown'}\n`;
            txt += `  â—¦ Bits: ${cipher.bits || 'Unknown'}\n`;
        }
        txt += `\n`;
        
        // SAN (Subject Alternative Names)
        if (cert.subjectaltname) {
            const sans = cert.subjectaltname.split(',').map(s => s.trim().replace('DNS:', '')).slice(0, 5);
            txt += `ğŸŒ *á´€ÊŸá´›á´‡Ê€É´á´€á´›Éªá´ á´‡ É´á´€á´á´‡s*\n`;
            txt += `â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„\n`;
            sans.forEach(san => txt += `  â—¦ ${san}\n`);
            if (cert.subjectaltname.split(',').length > 5) {
                txt += `  ... dan ${cert.subjectaltname.split(',').length - 5} lainnya\n`;
            }
            txt += `\n`;
        }
        
        // Fingerprints
        txt += `ğŸ”‘ *êœ°ÉªÉ´É¢á´‡Ê€á´˜Ê€ÉªÉ´á´›s*\n`;
        txt += `â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„\n`;
        if (cert.fingerprint256) {
            txt += `  â—¦ SHA-256: ${cert.fingerprint256.substring(0, 30)}...\n`;
        }
        if (cert.fingerprint) {
            txt += `  â—¦ SHA-1: ${cert.fingerprint.substring(0, 30)}...\n`;
        }
        
        await m.reply(txt);
        
    } catch (error) {
        await m.reply(`âŒ Error: ${error.message}`);
    }
}

module.exports = { config: pluginConfig, handler };
