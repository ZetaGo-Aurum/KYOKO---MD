/**
 * Subdomain Finder - KYOKO MD Pentest Feature
 * Find subdomains using public APIs (no dependencies)
 * Developer: ZetaGo-Aurum
 */

const https = require('https');

const pluginConfig = {
    name: 'subdomain',
    alias: ['subfinder', 'subdomains', 'sd'],
    category: 'pentest',
    description: 'Cari subdomain dari domain target',
    usage: '.subdomain <domain>',
    example: '.subdomain example.com',
    isOwner: false,
    isPremium: true,
    isGroup: false,
    isPrivate: false,
    cooldown: 30,
    limit: 1,
    isEnabled: true
};

/**
 * Fetch data from URL (native https)
 */
function fetchUrl(url) {
    return new Promise((resolve, reject) => {
        const req = https.get(url, { headers: { 'User-Agent': 'KYOKO-MD/1.0' } }, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => resolve(data));
        });
        req.on('error', reject);
        req.setTimeout(10000, () => {
            req.destroy();
            reject(new Error('Timeout'));
        });
    });
}

async function handler(m, { sock }) {
    const domain = m.text?.trim()?.toLowerCase();
    
    if (!domain) {
        return m.reply(`‚ùå Format: .subdomain <domain>\n\nContoh: .subdomain example.com`);
    }
    
    // Validate domain
    if (!/^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}$/.test(domain)) {
        return m.reply(`‚ùå Invalid domain format!`);
    }
    
    await m.reply(`üîç *Íú±·¥ú ô·¥Ö·¥è·¥ç·¥Ä…™…¥ Íú∞…™…¥·¥Ö·¥á Ä*\n\n‚è≥ Searching subdomains for ${domain}...\n> Mohon tunggu...`);
    
    try {
        const subdomains = new Set();
        
        // Source 1: crt.sh (Certificate Transparency)
        try {
            const crtData = await fetchUrl(`https://crt.sh/?q=%.${domain}&output=json`);
            const crtJson = JSON.parse(crtData);
            crtJson.forEach(entry => {
                const names = entry.name_value.split('\n');
                names.forEach(name => {
                    const clean = name.trim().toLowerCase();
                    if (clean.endsWith(domain) && !clean.includes('*')) {
                        subdomains.add(clean);
                    }
                });
            });
        } catch (e) {
            // Silent fail for this source
        }
        
        // Source 2: HackerTarget
        try {
            const htData = await fetchUrl(`https://api.hackertarget.com/hostsearch/?q=${domain}`);
            if (!htData.includes('error')) {
                htData.split('\n').forEach(line => {
                    const sub = line.split(',')[0]?.trim();
                    if (sub && sub.endsWith(domain)) {
                        subdomains.add(sub);
                    }
                });
            }
        } catch (e) {
            // Silent fail
        }
        
        const results = Array.from(subdomains).sort();
        
        let txt = `üîç *Íú±·¥ú ô·¥Ö·¥è·¥ç·¥Ä…™…¥  Ä·¥áÍú±·¥ú ü·¥õ*\n\n`;
        txt += `üéØ Domain: \`${domain}\`\n`;
        txt += `üìä Found: ${results.length} subdomains\n\n`;
        
        if (results.length > 0) {
            txt += `üìã *Íú±·¥ú ô·¥Ö·¥è·¥ç·¥Ä…™…¥Íú±*\n`;
            const display = results.slice(0, 30);
            display.forEach((sub, i) => {
                txt += `${i + 1}. ${sub}\n`;
            });
            
            if (results.length > 30) {
                txt += `\n> ... dan ${results.length - 30} subdomain lainnya`;
            }
        } else {
            txt += `> Tidak ada subdomain ditemukan.`;
        }
        
        await m.reply(txt);
        
    } catch (error) {
        await m.reply(`‚ùå Search gagal: ${error.message}`);
    }
}

module.exports = { config: pluginConfig, handler };
