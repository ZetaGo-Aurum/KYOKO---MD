/**
 * SQL Injection Checker - KYOKO MD Pentest Feature
 * Check for basic SQL injection vulnerabilities
 * Developer: ZetaGo-Aurum
 * 
 * WARNING: Only use on sites you own or have permission to test!
 */

const https = require('https');
const http = require('http');
const { URL } = require('url');

const pluginConfig = {
    name: 'sqlmap',
    alias: ['sqli', 'sqlcheck', 'sqltest'],
    category: 'pentest',
    description: 'Cek kerentanan SQL Injection pada URL',
    usage: '.sqlmap <url_dengan_parameter>',
    example: '.sqlmap https://example.com/page?id=1',
    isOwner: false,
    isPremium: true,
    isGroup: false,
    isPrivate: false,
    cooldown: 30,
    limit: 1,
    isEnabled: true
};

// SQL Injection payloads for detection
const SQLI_PAYLOADS = [
    "'",
    "\"",
    "' OR '1'='1",
    "\" OR \"1\"=\"1",
    "' OR 1=1--",
    "' OR 1=1#",
    "1' AND '1'='1",
    "1 AND 1=1",
    "' UNION SELECT NULL--",
    "1'; WAITFOR DELAY '0:0:5'--"
];

// Error patterns that indicate SQL injection vulnerability
const ERROR_PATTERNS = [
    /sql syntax/i,
    /mysql_fetch/i,
    /mysql_num_rows/i,
    /mysql_query/i,
    /pg_query/i,
    /pg_exec/i,
    /sqlite_query/i,
    /ORA-\d{5}/i,
    /Microsoft SQL Server/i,
    /ODBC Driver/i,
    /syntax error/i,
    /unclosed quotation/i,
    /unterminated string/i,
    /quoted string not properly terminated/i,
    /Warning.*mysql/i,
    /valid MySQL result/i,
    /PostgreSQL.*ERROR/i,
    /supplied argument is not a valid/i
];

function makeRequest(url, timeout = 8000) {
    return new Promise((resolve) => {
        try {
            const parsedUrl = new URL(url);
            const protocol = parsedUrl.protocol === 'https:' ? https : http;
            
            const req = protocol.get(url, {
                timeout,
                rejectUnauthorized: false,
                headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0' }
            }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve({ status: res.statusCode, body: data }));
            });
            
            req.on('error', () => resolve({ status: 0, error: true }));
            req.on('timeout', () => {
                req.destroy();
                resolve({ status: 0, timeout: true });
            });
        } catch (e) {
            resolve({ status: 0, error: true });
        }
    });
}

async function handler(m, { sock }) {
    const target = m.text?.trim();
    
    if (!target) {
        return m.reply(
            `üíâ *s«´ ü …™…¥·¥ä·¥á·¥Ñ·¥õ…™·¥è…¥ ·¥Ñ ú·¥á·¥Ñ·¥ã·¥á Ä*\n\n` +
            `> Cek kerentanan SQL Injection\n\n` +
            `*Penggunaan:*\n` +
            `> ${m.prefix}sqlmap <url_dengan_parameter>\n\n` +
            `*Contoh:*\n` +
            `> ${m.prefix}sqlmap https://site.com/page?id=1\n\n` +
            `> ‚ö†Ô∏è _Hanya gunakan pada situs milik sendiri!_`
        );
    }
    
    // Validate URL has parameters
    let testUrl;
    try {
        testUrl = new URL(target);
        if (!testUrl.search || testUrl.search === '?') {
            return m.reply(`‚ùå URL harus memiliki parameter!\n\nContoh: \`https://site.com/page?id=1\``);
        }
    } catch {
        return m.reply(`‚ùå URL tidak valid!`);
    }
    
    await m.reply(`üíâ *s«´ ü…™ ·¥Ñ ú·¥á·¥Ñ·¥ã·¥á Ä*\n\n‚è≥ Testing ${target}...\n> Mohon tunggu...`);
    
    try {
        const findings = [];
        const startTime = Date.now();
        const params = testUrl.searchParams;
        
        // Get baseline response
        const baseline = await makeRequest(target);
        const baselineLength = baseline.body?.length || 0;
        
        // Test each parameter
        for (const [key, value] of params) {
            for (const payload of SQLI_PAYLOADS) {
                const testParams = new URLSearchParams(params);
                testParams.set(key, value + payload);
                
                const testUrlStr = `${testUrl.origin}${testUrl.pathname}?${testParams.toString()}`;
                const result = await makeRequest(testUrlStr, 5000);
                
                if (result.timeout) {
                    findings.push({
                        param: key,
                        payload: payload,
                        type: 'TIME-BASED',
                        confidence: 'Medium'
                    });
                    break;
                }
                
                if (result.body) {
                    for (const pattern of ERROR_PATTERNS) {
                        if (pattern.test(result.body)) {
                            findings.push({
                                param: key,
                                payload: payload.substring(0, 20),
                                type: 'ERROR-BASED',
                                confidence: 'High'
                            });
                            break;
                        }
                    }
                }
                
                // Check for significant response difference
                if (result.body && Math.abs(result.body.length - baselineLength) > 500) {
                    const alreadyFound = findings.some(f => f.param === key);
                    if (!alreadyFound) {
                        findings.push({
                            param: key,
                            payload: payload.substring(0, 20),
                            type: 'RESPONSE-DIFF',
                            confidence: 'Low'
                        });
                    }
                }
            }
        }
        
        const scanTime = ((Date.now() - startTime) / 1000).toFixed(2);
        
        let txt = `üíâ *s«´ ü …™…¥·¥ä·¥á·¥Ñ·¥õ…™·¥è…¥ s·¥Ñ·¥Ä…¥  Ä·¥ás·¥ú ü·¥õ*\n\n`;
        txt += `üéØ Target: \`${testUrl.origin}${testUrl.pathname}\`\n`;
        txt += `üìä Params: ${params.toString().substring(0, 50)}\n`;
        txt += `‚è±Ô∏è Time: ${scanTime}s\n\n`;
        
        if (findings.length > 0) {
            txt += `‚ö†Ô∏è *·¥ò·¥è·¥õ·¥á…¥·¥õ…™·¥Ä ü s«´ ü…™* (${findings.length})\n`;
            txt += `‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ\n`;
            for (const f of findings) {
                txt += `  ‚ó¶ Param: \`${f.param}\`\n`;
                txt += `    Type: ${f.type}\n`;
                txt += `    Confidence: ${f.confidence}\n\n`;
            }
        } else {
            txt += `‚úÖ Tidak terdeteksi kerentanan SQL Injection.\n`;
        }
        
        txt += `\n> ‚ö†Ô∏è _Ini adalah scan dasar. False positive mungkin terjadi._`;
        
        await m.reply(txt);
        
    } catch (error) {
        await m.reply(`‚ùå Scan gagal: ${error.message}`);
    }
}

module.exports = { config: pluginConfig, handler };
